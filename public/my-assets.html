<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Assets ‚Äì Tree Clipper</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="login-corner"></div>
  <a href="index.html" class="back-button">‚Üê</a>

  <h1>My Assets</h1>

  <div id="login-prompt" class="login-prompt">
    <p>Please log in with Discord to view your assets.</p>
  </div>

  <div id="page-content" style="display: none;">
    <nav class="nav-links">
      <a href="my-assets.html" class="active">My Assets</a>
      <a href="settings.html">Settings</a>
    </nav>

    <ul id="my-assets-list" class="assets-list my-assets-list">
      <li class="loading-item">Loading your assets...</li>
    </ul>

    <a href="upload-asset.html" class="upload-btn">+ Upload New Asset</a>
  </div>

  <!-- Edit Modal -->
  <div id="edit-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <button class="modal-close" id="modal-close">√ó</button>
      <h2>Edit Asset</h2>
      
      <form id="edit-form" class="asset-form">
        <input type="hidden" id="edit-author" />
        <input type="hidden" id="edit-slug" />
        
        <div class="form-group">
          <label>Title</label>
          <input type="text" id="edit-title" disabled style="background: #f3f4f6; cursor: not-allowed;" />
          <small style="color: #6b7280; font-size: 0.85em;">Title cannot be changed (used in URL)</small>
        </div>

        <div class="form-group">
          <label for="edit-description">Description</label>
          <textarea id="edit-description" rows="3" placeholder="Brief description"></textarea>
        </div>

        <div class="form-group">
          <label for="edit-asset-data">Asset Data *</label>
          <textarea id="edit-asset-data" rows="4" required placeholder="TreeClipper::H4sIALGFY2kC/+1aW2/iOBT..."></textarea>
        </div>

        <div id="edit-asset-meta" class="asset-meta" style="display: none;">
          <div class="meta-row">
            <span class="meta-label">Type</span>
            <span id="edit-meta-node-type" class="meta-value"></span>
          </div>
          <div class="meta-row">
            <span class="meta-label">Blender</span>
            <span id="edit-meta-blender-version" class="meta-value"></span>
          </div>
          <div class="meta-row">
            <span class="meta-label">TreeClipper</span>
            <span id="edit-meta-treeclipper-version" class="meta-value"></span>
          </div>
        </div>

        <div class="form-group">
          <label>Preview Image</label>
          <div class="current-image-preview" id="current-image-container">
            <img id="current-image" src="" alt="Current preview" />
            <button type="button" id="remove-current-image" class="remove-image-btn">Remove Image</button>
          </div>
          <div class="image-dropzone" id="edit-image-dropzone">
            <input type="file" id="edit-image-input" accept="image/*" hidden />
            <div class="dropzone-content">
              <span class="dropzone-icon">üì∑</span>
              <span class="dropzone-text">Click, drag, or paste a new image</span>
            </div>
            <img id="edit-image-preview" class="image-preview" alt="Preview" />
            <button type="button" id="edit-remove-image" class="remove-image">√ó</button>
          </div>
        </div>

        <div class="modal-actions">
          <button type="button" id="cancel-edit" class="btn-secondary">Cancel</button>
          <button type="submit" class="btn-primary">Save Changes</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Delete Confirmation Modal -->
  <div id="delete-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content modal-small">
      <h2>Delete Asset?</h2>
      <p id="delete-asset-name" class="delete-warning"></p>
      <p class="delete-warning-sub">This action cannot be undone.</p>
      <div class="modal-actions">
        <button type="button" id="cancel-delete" class="btn-secondary">Cancel</button>
        <button type="button" id="confirm-delete" class="btn-danger">Delete</button>
      </div>
    </div>
  </div>

  <div id="output" class="status-message">
    <span class="status-icon"></span>
    <span class="status-text"></span>
  </div>

  <!-- Image Cropper Modal -->
  <div id="cropper-modal" class="cropper-overlay" style="display: none;">
    <div class="cropper-modal">
      <div class="cropper-header">
        <div>
          <h3>Crop Thumbnail</h3>
          <p>Drag to move, drag corners to resize. Thumbnail will be square.</p>
        </div>
      </div>
      <div class="cropper-container" id="cropper-container">
        <img id="cropper-image" class="cropper-image" alt="Crop preview" />
        <div class="crop-area" id="crop-area">
          <div class="crop-handle crop-handle--nw" data-handle="nw"></div>
          <div class="crop-handle crop-handle--ne" data-handle="ne"></div>
          <div class="crop-handle crop-handle--sw" data-handle="sw"></div>
          <div class="crop-handle crop-handle--se" data-handle="se"></div>
        </div>
        <div class="crop-size-indicator" id="crop-size-indicator"></div>
      </div>
      <div class="cropper-actions">
        <button type="button" class="btn-cancel-crop" id="cancel-crop">Cancel</button>
        <button type="button" class="btn-crop" id="confirm-crop">Crop & Use</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { supabase, initLoginCorner, ensureUsername } from "./auth.js";

    initLoginCorner();
    
    // Ensure user has a username before showing content
    await ensureUsername();

    const loginPrompt = document.getElementById("login-prompt");
    const pageContent = document.getElementById("page-content");
    const assetsList = document.getElementById("my-assets-list");
    const output = document.getElementById("output");
    const statusIcon = output.querySelector(".status-icon");
    const statusText = output.querySelector(".status-text");

    // Edit modal elements
    const editModal = document.getElementById("edit-modal");
    const editForm = document.getElementById("edit-form");
    const editAuthor = document.getElementById("edit-author");
    const editSlug = document.getElementById("edit-slug");
    const editTitle = document.getElementById("edit-title");
    const editDescription = document.getElementById("edit-description");
    const editAssetData = document.getElementById("edit-asset-data");
    const currentImageContainer = document.getElementById("current-image-container");
    const currentImage = document.getElementById("current-image");
    const removeCurrentImageBtn = document.getElementById("remove-current-image");
    const editImageDropzone = document.getElementById("edit-image-dropzone");
    const editImageInput = document.getElementById("edit-image-input");
    const editImagePreview = document.getElementById("edit-image-preview");
    const editRemoveImage = document.getElementById("edit-remove-image");

    // Delete modal elements
    const deleteModal = document.getElementById("delete-modal");
    const deleteAssetName = document.getElementById("delete-asset-name");
    let deleteAuthor = null;
    let deleteSlug = null;

    // Edit meta elements
    const editAssetMeta = document.getElementById("edit-asset-meta");
    const editMetaNodeType = document.getElementById("edit-meta-node-type");
    const editMetaBlenderVersion = document.getElementById("edit-meta-blender-version");
    const editMetaTreeclipperVersion = document.getElementById("edit-meta-treeclipper-version");

    let currentSession = null;
    let statusTimeout;
    let selectedNewImage = null;
    let currentImageUrl = null;
    let parsedAssetMeta = null;

    // ---------------- IMAGE CROPPER ----------------
    const cropperModal = document.getElementById("cropper-modal");
    const cropperContainer = document.getElementById("cropper-container");
    const cropperImage = document.getElementById("cropper-image");
    const cropArea = document.getElementById("crop-area");
    const cropSizeIndicator = document.getElementById("crop-size-indicator");
    const cancelCropBtn = document.getElementById("cancel-crop");
    const confirmCropBtn = document.getElementById("confirm-crop");

    let pendingImageFile = null;
    let cropState = {
      imageWidth: 0,
      imageHeight: 0,
      containerWidth: 0,
      containerHeight: 0,
      offsetX: 0,
      offsetY: 0,
      cropX: 0,
      cropY: 0,
      cropSize: 100,
      dragging: false,
      resizing: false,
      resizeHandle: null,
      startX: 0,
      startY: 0,
      startCropX: 0,
      startCropY: 0,
      startCropSize: 0
    };

    function openCropper(file) {
      pendingImageFile = file;
      const url = URL.createObjectURL(file);
      cropperImage.onload = () => {
        initCropArea();
        URL.revokeObjectURL(url);
      };
      cropperImage.src = url;
      cropperModal.style.display = "flex";
    }

    function closeCropper() {
      cropperModal.style.display = "none";
      pendingImageFile = null;
    }

    function initCropArea() {
      const rect = cropperImage.getBoundingClientRect();
      const containerRect = cropperContainer.getBoundingClientRect();
      
      cropState.imageWidth = rect.width;
      cropState.imageHeight = rect.height;
      cropState.containerWidth = containerRect.width;
      cropState.containerHeight = containerRect.height;
      cropState.offsetX = rect.left - containerRect.left;
      cropState.offsetY = rect.top - containerRect.top;
      
      // Start with the largest square that fits, centered
      const minDim = Math.min(rect.width, rect.height);
      cropState.cropSize = Math.min(minDim * 0.8, 300);
      cropState.cropX = cropState.offsetX + (rect.width - cropState.cropSize) / 2;
      cropState.cropY = cropState.offsetY + (rect.height - cropState.cropSize) / 2;
      
      updateCropAreaDisplay();
    }

    function updateCropAreaDisplay() {
      cropArea.style.left = cropState.cropX + "px";
      cropArea.style.top = cropState.cropY + "px";
      cropArea.style.width = cropState.cropSize + "px";
      cropArea.style.height = cropState.cropSize + "px";
      
      // Calculate actual pixel size based on natural image dimensions
      const scaleX = cropperImage.naturalWidth / cropState.imageWidth;
      const actualSize = Math.round(cropState.cropSize * scaleX);
      cropSizeIndicator.textContent = `${actualSize} √ó ${actualSize}px`;
    }

    function constrainCrop() {
      const minSize = 50;
      const maxSize = Math.min(cropState.imageWidth, cropState.imageHeight);
      
      cropState.cropSize = Math.max(minSize, Math.min(cropState.cropSize, maxSize));
      cropState.cropX = Math.max(cropState.offsetX, Math.min(cropState.cropX, cropState.offsetX + cropState.imageWidth - cropState.cropSize));
      cropState.cropY = Math.max(cropState.offsetY, Math.min(cropState.cropY, cropState.offsetY + cropState.imageHeight - cropState.cropSize));
    }

    // Mouse/touch event handlers
    function getEventPos(e) {
      if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      return { x: e.clientX, y: e.clientY };
    }

    function handleCropStart(e) {
      e.preventDefault();
      const pos = getEventPos(e);
      const handle = e.target.dataset?.handle;
      
      cropState.startX = pos.x;
      cropState.startY = pos.y;
      cropState.startCropX = cropState.cropX;
      cropState.startCropY = cropState.cropY;
      cropState.startCropSize = cropState.cropSize;
      
      if (handle) {
        cropState.resizing = true;
        cropState.resizeHandle = handle;
      } else if (e.target === cropArea || e.target.closest("#crop-area")) {
        cropState.dragging = true;
      }
    }

    function handleCropMove(e) {
      if (!cropState.dragging && !cropState.resizing) return;
      e.preventDefault();
      
      const pos = getEventPos(e);
      const dx = pos.x - cropState.startX;
      const dy = pos.y - cropState.startY;
      
      if (cropState.dragging) {
        cropState.cropX = cropState.startCropX + dx;
        cropState.cropY = cropState.startCropY + dy;
      } else if (cropState.resizing) {
        // For square crop, use the larger delta to determine size change
        const handle = cropState.resizeHandle;
        let sizeDelta = 0;
        
        if (handle === "se") {
          sizeDelta = Math.max(dx, dy);
        } else if (handle === "sw") {
          sizeDelta = Math.max(-dx, dy);
          cropState.cropX = cropState.startCropX - (cropState.startCropSize + sizeDelta - cropState.startCropSize);
        } else if (handle === "ne") {
          sizeDelta = Math.max(dx, -dy);
          cropState.cropY = cropState.startCropY - (cropState.startCropSize + sizeDelta - cropState.startCropSize);
        } else if (handle === "nw") {
          sizeDelta = Math.max(-dx, -dy);
          cropState.cropX = cropState.startCropX - sizeDelta;
          cropState.cropY = cropState.startCropY - sizeDelta;
        }
        
        cropState.cropSize = cropState.startCropSize + sizeDelta;
      }
      
      constrainCrop();
      updateCropAreaDisplay();
    }

    function handleCropEnd() {
      cropState.dragging = false;
      cropState.resizing = false;
      cropState.resizeHandle = null;
    }

    cropArea.addEventListener("mousedown", handleCropStart);
    cropArea.addEventListener("touchstart", handleCropStart, { passive: false });
    document.addEventListener("mousemove", handleCropMove);
    document.addEventListener("touchmove", handleCropMove, { passive: false });
    document.addEventListener("mouseup", handleCropEnd);
    document.addEventListener("touchend", handleCropEnd);

    cancelCropBtn.addEventListener("click", closeCropper);
    
    confirmCropBtn.addEventListener("click", async () => {
      if (!pendingImageFile) return;
      
      // Calculate crop coordinates in original image space
      const scaleX = cropperImage.naturalWidth / cropState.imageWidth;
      const scaleY = cropperImage.naturalHeight / cropState.imageHeight;
      
      const sourceX = (cropState.cropX - cropState.offsetX) * scaleX;
      const sourceY = (cropState.cropY - cropState.offsetY) * scaleY;
      const sourceSize = cropState.cropSize * scaleX;
      
      // Create cropped image
      const canvas = document.createElement("canvas");
      const outputSize = Math.min(512, Math.round(sourceSize)); // Max 512px for thumbnails
      canvas.width = outputSize;
      canvas.height = outputSize;
      
      const ctx = canvas.getContext("2d");
      ctx.drawImage(
        cropperImage,
        sourceX, sourceY, sourceSize, sourceSize,
        0, 0, outputSize, outputSize
      );
      
      // Convert to blob
      const croppedBlob = await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg", 0.92));
      
      selectedNewImage = croppedBlob;
      editImagePreview.src = URL.createObjectURL(croppedBlob);
      editImageDropzone.classList.add("has-image");
      currentImageContainer.style.display = "none";
      
      closeCropper();
    });

    // ---------------- AUTH STATE ----------------
    function updateAuthUI(user) {
      if (user) {
        loginPrompt.style.display = "none";
        pageContent.style.display = "";
        loadMyAssets();
      } else {
        loginPrompt.style.display = "";
        pageContent.style.display = "none";
      }
    }

    supabase.auth.getSession().then(({ data: { session } }) => {
      currentSession = session;
      updateAuthUI(session?.user ?? null);
    });

    supabase.auth.onAuthStateChange((event, session) => {
      currentSession = session;
      updateAuthUI(session?.user ?? null);
    });

    // ---------------- STATUS MESSAGES ----------------
    function showStatus(type, message) {
      clearTimeout(statusTimeout);
      output.classList.remove("fade-out");
      output.className = "status-message visible " + type;
      statusIcon.textContent = type === "success" ? "‚úì" : type === "error" ? "‚úï" : "‚Ñπ";
      statusText.textContent = message;
      
      statusTimeout = setTimeout(() => {
        output.classList.add("fade-out");
        setTimeout(() => {
          output.classList.remove("visible", "fade-out");
        }, 400);
      }, 2000);
    }

    // ---------------- LOAD ASSETS ----------------
    async function loadMyAssets() {
      if (!currentSession) return;

      assetsList.innerHTML = '<li class="loading-item">Loading your assets...</li>';

      try {
        const res = await fetch("/api/entries?mine=true", {
          headers: {
            "Authorization": `Bearer ${currentSession.access_token}`
          }
        });

        if (!res.ok) throw new Error("Failed to fetch");

        const entries = await res.json();

        if (!entries || entries.length === 0) {
          assetsList.innerHTML = '<li class="empty-item">You haven\'t uploaded any assets yet.</li>';
          return;
        }

        assetsList.innerHTML = entries.map(entry => {
          const title = entry.title || "Untitled Asset";
          const imageUrl = entry.image_data;
          const imageHtml = imageUrl 
            ? `<img src="${escapeHtml(imageUrl)}" alt="" class="asset-thumb" loading="lazy">`
            : `<div class="asset-thumb-placeholder">üì¶</div>`;
          
          // Build tags HTML
          let tagsHtml = '';
          if (entry.node_type || entry.blender_version) {
            tagsHtml = '<div class="asset-tags">';
            if (entry.node_type) {
              const nodeLabel = formatNodeType(entry.node_type);
              const nodeIcon = getNodeTypeIcon(entry.node_type);
              tagsHtml += `<span class="asset-tag asset-tag--${entry.node_type}">${nodeIcon} ${nodeLabel}</span>`;
            }
            if (entry.blender_version) {
              tagsHtml += `<span class="asset-tag asset-tag--blender">Blender ${escapeHtml(entry.blender_version)}</span>`;
            }
            tagsHtml += '</div>';
          }
          
          const assetUrl = `/${encodeURIComponent(entry.author)}/${encodeURIComponent(entry.slug)}`;
          
          return `
            <li data-slug="${escapeHtml(entry.slug || '')}" data-author="${escapeHtml(entry.author || '')}">
              <div class="my-assets-row">
                <a href="${assetUrl}" class="asset-link">
                  ${imageHtml}
                  <div class="asset-info">
                    <span class="asset-title">${escapeHtml(title)}</span>
                    <span class="asset-date">${formatDate(entry.creation_date)}</span>
                    ${tagsHtml}
                  </div>
                </a>
                <div class="asset-actions">
                  <button class="btn-edit" data-author="${escapeHtml(entry.author || '')}" data-slug="${escapeHtml(entry.slug || '')}" title="Edit">‚úèÔ∏è</button>
                  <button class="btn-delete" data-author="${escapeHtml(entry.author || '')}" data-slug="${escapeHtml(entry.slug || '')}" data-title="${escapeHtml(title)}" title="Delete">üóëÔ∏è</button>
                </div>
              </div>
            </li>
          `;
        }).join('');

        // Attach event listeners
        assetsList.querySelectorAll(".btn-edit").forEach(btn => {
          btn.addEventListener("click", () => openEditModal(btn.dataset.author, btn.dataset.slug));
        });

        assetsList.querySelectorAll(".btn-delete").forEach(btn => {
          btn.addEventListener("click", () => openDeleteModal(btn.dataset.author, btn.dataset.slug, btn.dataset.title));
        });

      } catch (err) {
        console.error("Failed to load assets:", err);
        assetsList.innerHTML = '<li class="error-item">Failed to load your assets. Please try again.</li>';
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatDate(isoString) {
      if (!isoString) return "";
      const date = new Date(isoString);
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    }

    function formatNodeType(nodeType) {
      const labels = {
        'geonodes': 'Geo Nodes',
        'shader': 'Shader',
        'compositor': 'Compositor'
      };
      return labels[nodeType] || nodeType;
    }

    function getNodeTypeIcon(nodeType) {
      const icons = {
        'geonodes': '‚óá',
        'shader': '‚óê',
        'compositor': '‚ñ£'
      };
      return icons[nodeType] || '‚óè';
    }

    function getNodeTypeLabel(nodeType) {
      const labels = {
        'geonodes': 'Geometry Nodes',
        'shader': 'Shader',
        'compositor': 'Compositor'
      };
      return labels[nodeType] || nodeType;
    }

    // ---------------- TREECLIPPER DECODING ----------------
    function base64ToUint8Array(b64) {
      b64 = b64.replace(/\s/g, '');
      const binaryString = atob(b64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }

    async function ungzip(bytes) {
      if (typeof DecompressionStream === "undefined") {
        throw new Error("Browser does not support DecompressionStream");
      }
      const cs = new DecompressionStream('gzip');
      const blob = new Blob([bytes]);
      const decompressedStream = blob.stream().pipeThrough(cs);
      const decompressed = await new Response(decompressedStream).arrayBuffer();
      return new TextDecoder().decode(decompressed);
    }

    function mapBlIdnameToType(blIdname) {
      const mapping = {
        'GeometryNodeTree': 'geonodes',
        'ShaderNodeTree': 'shader',
        'CompositorNodeTree': 'compositor'
      };
      return mapping[blIdname] || blIdname || 'unknown';
    }

    async function decodeTreeClipperData(raw) {
      if (!raw.startsWith('TreeClipper::')) return null;
      const parts = raw.split('::');
      if (parts.length !== 2) return null;
      
      try {
        const bytes = base64ToUint8Array(parts[1]);
        const json = await ungzip(bytes);
        const obj = JSON.parse(json);
        
        // Extract metadata
        const blenderVersion = obj.blender_version || null;
        const treeclipperVersion = obj.tree_clipper_version || null;
        
        // Get node type from the last node_tree's bl_idname
        let nodeType = null;
        if (Array.isArray(obj.node_trees) && obj.node_trees.length > 0) {
          const lastTree = obj.node_trees[obj.node_trees.length - 1];
          const blIdname = lastTree?.data?.bl_idname;
          nodeType = mapBlIdnameToType(blIdname);
        }
        
        return {
          blenderVersion,
          treeclipperVersion,
          nodeType
        };
      } catch (e) {
        console.error("Failed to decode TreeClipper data:", e);
        return null;
      }
    }

    async function updateEditAssetMeta() {
      const raw = editAssetData.value.trim();
      if (!raw) {
        editAssetMeta.style.display = "none";
        parsedAssetMeta = null;
        return;
      }
      
      const meta = await decodeTreeClipperData(raw);
      parsedAssetMeta = meta;
      
      if (meta && (meta.nodeType || meta.blenderVersion || meta.treeclipperVersion)) {
        editMetaNodeType.textContent = meta.nodeType ? getNodeTypeLabel(meta.nodeType) : '‚Äî';
        editMetaBlenderVersion.textContent = meta.blenderVersion || '‚Äî';
        editMetaTreeclipperVersion.textContent = meta.treeclipperVersion || '‚Äî';
        editAssetMeta.style.display = "";
      } else {
        editAssetMeta.style.display = "none";
      }
    }

    // ---------------- EDIT MODAL ----------------
    async function openEditModal(author, slug) {
      try {
        const res = await fetch(`/api/asset/${encodeURIComponent(author)}/${encodeURIComponent(slug)}`);
        if (!res.ok) throw new Error("Asset not found");
        
        const asset = await res.json();
        
        editAuthor.value = asset.author;
        editSlug.value = asset.slug;
        editTitle.value = asset.title || "";
        editDescription.value = asset.description || "";
        editAssetData.value = asset.asset_data || "";
        
        // Handle current image
        currentImageUrl = asset.image_data;
        selectedNewImage = null;
        
        if (currentImageUrl) {
          currentImage.src = currentImageUrl;
          currentImageContainer.style.display = "block";
        } else {
          currentImageContainer.style.display = "none";
        }
        
        // Reset new image dropzone
        editImagePreview.src = "";
        editImageDropzone.classList.remove("has-image");
        editImageInput.value = "";
        
        // Parse and display asset metadata
        await updateEditAssetMeta();
        
        editModal.style.display = "flex";
      } catch (err) {
        showStatus("error", "Failed to load asset details");
      }
    }

    // Update metadata when asset data changes
    editAssetData.addEventListener("input", updateEditAssetMeta);

    function closeEditModal() {
      editModal.style.display = "none";
      editForm.reset();
      selectedNewImage = null;
      parsedAssetMeta = null;
      editAssetMeta.style.display = "none";
    }

    document.getElementById("modal-close").addEventListener("click", closeEditModal);
    document.getElementById("cancel-edit").addEventListener("click", closeEditModal);
    
    editModal.addEventListener("click", (e) => {
      if (e.target === editModal) closeEditModal();
    });

    // Current image removal - immediately delete from storage
    removeCurrentImageBtn.addEventListener("click", async () => {
      if (!currentSession || !currentImageUrl) return;

      const author = editAuthor.value;
      const slug = editSlug.value;
      removeCurrentImageBtn.disabled = true;
      removeCurrentImageBtn.textContent = "Removing...";

      try {
        const res = await fetch(`/api/entries?author=${encodeURIComponent(author)}&slug=${encodeURIComponent(slug)}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${currentSession.access_token}`
          },
          body: JSON.stringify({ imageData: null })
        });

        if (res.ok) {
          currentImageUrl = null;
          currentImageContainer.style.display = "none";
          showStatus("success", "Image removed");
        } else {
          showStatus("error", "Failed to remove image");
        }
      } catch (err) {
        showStatus("error", "Failed to remove image");
      } finally {
        removeCurrentImageBtn.disabled = false;
        removeCurrentImageBtn.textContent = "Remove Image";
      }
    });

    // New image dropzone
    editImageDropzone.addEventListener("click", () => editImageInput.click());

    editImageDropzone.addEventListener("dragover", e => {
      e.preventDefault();
      editImageDropzone.classList.add("dragover");
    });

    editImageDropzone.addEventListener("dragleave", () => {
      editImageDropzone.classList.remove("dragover");
    });

    editImageDropzone.addEventListener("drop", e => {
      e.preventDefault();
      editImageDropzone.classList.remove("dragover");
      const file = e.dataTransfer.files[0];
      if (file?.type.startsWith("image/")) openCropper(file);
    });

    editImageInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (file) openCropper(file);
    });

    editRemoveImage.addEventListener("click", e => {
      e.stopPropagation();
      selectedNewImage = null;
      editImageInput.value = "";
      editImagePreview.src = "";
      editImageDropzone.classList.remove("has-image");
      // Show current image again if it exists
      if (currentImageUrl) {
        currentImageContainer.style.display = "block";
      }
    });

    // Handle paste for images in edit modal
    document.addEventListener("paste", e => {
      if (editModal.style.display !== "flex") return;
      if (cropperModal.style.display === "flex") return; // Don't intercept if cropper is open
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith("image/")) {
          e.preventDefault();
          const file = item.getAsFile();
          if (file) openCropper(file);
          break;
        }
      }
    });

    // Submit edit form
    editForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      if (!currentSession) {
        showStatus("error", "Please log in to edit assets");
        return;
      }

      const author = editAuthor.value;
      const slug = editSlug.value;
      let imageUrl = undefined; // undefined = don't change

      // Handle new image upload
      if (selectedNewImage) {
        // Get username for folder path
        const profileRes = await fetch("/api/users/me", {
          headers: { "Authorization": `Bearer ${currentSession.access_token}` }
        });
        const profile = await profileRes.json();
        if (!profile?.username) {
          showStatus("error", "Please set a username first");
          return;
        }
        
        // Cropped images are always JPEG
        const filePath = `${profile.username}/asset-${Date.now()}.jpg`;

        const { error } = await supabase.storage
          .from("asset-images")
          .upload(filePath, selectedNewImage, {
            contentType: "image/jpeg"
          });

        if (error) {
          showStatus("error", "Image upload failed: " + error.message);
          return;
        }

        imageUrl = supabase.storage
          .from("asset-images")
          .getPublicUrl(filePath).data.publicUrl;
      }

      const payload = {
        // Title cannot be changed - it determines the URL
        description: editDescription.value.trim() || null,
        assetData: editAssetData.value.trim(),
        nodeType: parsedAssetMeta?.nodeType || null,
        blenderVersion: parsedAssetMeta?.blenderVersion || null,
        treeclipperVersion: parsedAssetMeta?.treeclipperVersion || null
      };

      if (imageUrl !== undefined) {
        payload.imageData = imageUrl;
      }

      try {
        const res = await fetch(`/api/entries?author=${encodeURIComponent(author)}&slug=${encodeURIComponent(slug)}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${currentSession.access_token}`
          },
          body: JSON.stringify(payload)
        });

        if (res.ok) {
          showStatus("success", "Asset updated!");
          closeEditModal();
          loadMyAssets();
        } else {
          showStatus("error", await res.text());
        }
      } catch (err) {
        showStatus("error", "Failed to update asset");
      }
    });

    // ---------------- DELETE MODAL ----------------
    function openDeleteModal(author, slug, title) {
      deleteAuthor = author;
      deleteSlug = slug;
      deleteAssetName.textContent = `"${title}"`;
      deleteModal.style.display = "flex";
    }

    function closeDeleteModal() {
      deleteModal.style.display = "none";
      deleteAuthor = null;
      deleteSlug = null;
    }

    document.getElementById("cancel-delete").addEventListener("click", closeDeleteModal);
    
    deleteModal.addEventListener("click", (e) => {
      if (e.target === deleteModal) closeDeleteModal();
    });

    document.getElementById("confirm-delete").addEventListener("click", async () => {
      if (!currentSession) {
        showStatus("error", "Please log in to delete assets");
        return;
      }

      if (!deleteAuthor || !deleteSlug) {
        showStatus("error", "Missing asset information");
        return;
      }

      try {
        const res = await fetch(`/api/entries?author=${encodeURIComponent(deleteAuthor)}&slug=${encodeURIComponent(deleteSlug)}`, {
          method: "DELETE",
          headers: {
            "Authorization": `Bearer ${currentSession.access_token}`
          }
        });

        if (res.ok) {
          showStatus("success", "Asset deleted");
          closeDeleteModal();
          loadMyAssets();
        } else {
          showStatus("error", await res.text());
        }
      } catch (err) {
        showStatus("error", "Failed to delete asset");
      }
    });

    // Close modals with Escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (cropperModal.style.display === "flex") {
          closeCropper();
        } else if (editModal.style.display === "flex") {
          closeEditModal();
        } else if (deleteModal.style.display === "flex") {
          closeDeleteModal();
        }
      }
    });
  </script>
  
  <div class="prototype-warning">Early Prototype, data not yet persistent</div>
</body>
</html>
